"""
Session Recording for MCP Server

Records commands, state changes, and events to YAML files for:
- Debugging failed sessions
- Converting successful sessions to reusable routines
- Understanding patterns and pitfalls

Three recording modes:
1. Always-on command log: Every command is logged to daily file (lightweight)
2. Explicit session recording: Full state tracking with deltas (start/stop)
3. Always-on action log: Plugin-side recording of manual play clicks (ActionRecorder)

Usage:
    # Commands are ALWAYS logged to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml

    # Manual play actions are ALWAYS logged to /tmp/manny_<account>_actions.json
    # Read with: get_action_log(since_seconds=300)

    # For full session tracking:
    start_session_recording(goal="Complete quest X")
    # ... autonomous play ...
    add_session_marker(label="Phase 2 complete")
    # ... more play ...
    stop_session_recording()  # Returns filepath
"""

import yaml
import json
import os
import time
from datetime import datetime, date
from pathlib import Path
from typing import Optional, Dict, Any, List, Set

from ..registry import registry


# ============================================================================
# Always-On Command Log (lightweight, daily files)
# ============================================================================

class CommandLog:
    """
    Always-on command logging to daily files.

    Every command is appended to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml
    This runs regardless of whether explicit session recording is active.
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self.output_dir = Path("/tmp/manny_sessions")
        self._current_date: Optional[date] = None
        self._current_file: Optional[Path] = None
        self._initialized = True

    def _get_daily_file(self) -> Path:
        """Get the log file for today, creating if needed."""
        today = date.today()

        # Check if we need to rotate to new day's file
        if self._current_date != today:
            self._current_date = today
            self._current_file = self.output_dir / f"commands_{today.isoformat()}.yaml"

            # Ensure directory exists
            self.output_dir.mkdir(parents=True, exist_ok=True)

            # Initialize file with header if new
            if not self._current_file.exists():
                with open(self._current_file, 'w') as f:
                    f.write(f"# Command log for {today.isoformat()}\n")
                    f.write("# Auto-generated by manny MCP server\n")
                    f.write("commands:\n")

        return self._current_file

    def log_command(self, command: str):
        """Append a command to today's log file."""
        try:
            filepath = self._get_daily_file()
            timestamp = datetime.now().isoformat(timespec='milliseconds')

            # Append as YAML list item
            with open(filepath, 'a') as f:
                f.write(f"  - timestamp: \"{timestamp}\"\n")
                # Escape quotes in command for YAML safety
                escaped_cmd = command.replace('"', '\\"')
                f.write(f"    command: \"{escaped_cmd}\"\n")
        except Exception:
            # Don't let logging failures break command execution
            pass

    def get_recent_commands(self, n: int = 50, date_str: str = None) -> List[Dict[str, str]]:
        """Get recent commands from log file."""
        if date_str:
            filepath = self.output_dir / f"commands_{date_str}.yaml"
        else:
            filepath = self._get_daily_file()

        if not filepath or not filepath.exists():
            return []

        try:
            with open(filepath) as f:
                data = yaml.safe_load(f)

            commands = data.get("commands", []) if data else []
            return commands[-n:] if commands else []
        except Exception:
            return []

    def get_log_files(self) -> List[str]:
        """List available command log files."""
        if not self.output_dir.exists():
            return []

        files = sorted(self.output_dir.glob("commands_*.yaml"), reverse=True)
        return [f.name for f in files]


# Singleton instance for always-on logging
command_log = CommandLog()


class SessionRecorder:
    """
    Singleton session recorder that captures commands and state deltas.

    Design decisions:
    - Delta-only state recording (not full snapshots) to keep files small
    - Explicit lifecycle (start/stop) not always-on
    - Command-result correlation via IDs
    - Buffered writes for performance
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self.active = False
        self.session_id: Optional[str] = None
        self.events: List[Dict[str, Any]] = []
        self.last_state: Optional[Dict[str, Any]] = None
        self.command_counter = 0
        self.goal: Optional[str] = None
        self.output_dir = Path("/tmp/manny_sessions")
        self._initialized = True

    def start(self, goal: str = None, account: str = None) -> str:
        """Start a new recording session."""
        self.session_id = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.events = []
        self.last_state = None
        self.command_counter = 0
        self.goal = goal
        self.active = True

        self._record({
            "type": "session_start",
            "goal": goal,
            "account": account
        })

        return self.session_id

    def record_command(self, command: str, description: str = None) -> Optional[int]:
        """Record a command being sent. Returns command ID for correlation."""
        if not self.active:
            return None

        self.command_counter += 1
        event = {
            "type": "command",
            "id": self.command_counter,
            "command": command
        }
        if description:
            event["description"] = description

        self._record(event)
        return self.command_counter

    def record_command_result(self, command_id: int, success: bool, error: str = None):
        """Record the result of a command."""
        if not self.active or command_id is None:
            return

        event = {
            "type": "command_result",
            "command_id": command_id,
            "success": success
        }
        if error:
            event["error"] = error

        self._record(event)

    def record_state_delta(self, new_state: dict, command_id: int = None):
        """Record state changes (delta only, not full state)."""
        if not self.active:
            return

        # First state - just store it, don't record
        if self.last_state is None:
            self.last_state = self._extract_trackable_state(new_state)
            return

        new_trackable = self._extract_trackable_state(new_state)
        delta = self._compute_delta(self.last_state, new_trackable)

        if delta:
            event = {"type": "state_delta", "changes": delta}
            if command_id:
                event["triggered_by"] = command_id
            self._record(event)

        self.last_state = new_trackable

    def _extract_trackable_state(self, state: dict) -> dict:
        """Extract the parts of state we track for deltas."""
        player = state.get("player", {})
        return {
            "location": player.get("location"),
            "inventory_items": frozenset(
                item.get("name", "")
                for item in player.get("inventory", {}).get("items", [])
            ),
            "inventory_count": player.get("inventory", {}).get("used", 0),
            "equipment": frozenset(
                v.get("name", "")
                for k, v in player.get("equipment", {}).items()
                if isinstance(v, dict) and v.get("name")
            ),
            "dialogue_open": state.get("dialogue", {}).get("open", False),
            "dialogue_type": state.get("dialogue", {}).get("type"),
            "health": player.get("health", {}).get("current"),
            "in_combat": player.get("inCombat", False),
            "plane": player.get("location", {}).get("plane")
        }

    def _compute_delta(self, old: dict, new: dict) -> dict:
        """Compute what changed between two states."""
        delta = {}

        # Location change
        if old.get("location") != new.get("location"):
            delta["location"] = new.get("location")

        # Plane change (important for ladders/stairs)
        if old.get("plane") != new.get("plane"):
            delta["plane"] = new.get("plane")

        # Inventory changes
        old_items = old.get("inventory_items", frozenset())
        new_items = new.get("inventory_items", frozenset())

        if added := new_items - old_items:
            delta["inventory_added"] = sorted(added)
        if removed := old_items - new_items:
            delta["inventory_removed"] = sorted(removed)

        # Inventory count
        if old.get("inventory_count") != new.get("inventory_count"):
            delta["inventory_count"] = new.get("inventory_count")

        # Equipment changes
        old_equip = old.get("equipment", frozenset())
        new_equip = new.get("equipment", frozenset())

        if equipped := new_equip - old_equip:
            delta["equipped"] = sorted(equipped)
        if unequipped := old_equip - new_equip:
            delta["unequipped"] = sorted(unequipped)

        # Dialogue state
        if old.get("dialogue_open") != new.get("dialogue_open"):
            delta["dialogue_open"] = new.get("dialogue_open")
        if old.get("dialogue_type") != new.get("dialogue_type"):
            delta["dialogue_type"] = new.get("dialogue_type")

        # Health
        if old.get("health") != new.get("health"):
            delta["health"] = new.get("health")

        # Combat state
        if old.get("in_combat") != new.get("in_combat"):
            delta["in_combat"] = new.get("in_combat")

        return delta

    def add_marker(self, label: str, note: str = None):
        """Add a marker/checkpoint to the session."""
        if not self.active:
            return

        event = {"type": "marker", "label": label}
        if note:
            event["note"] = note
        self._record(event)

    def record_error(self, command: str, error: str, context: dict = None):
        """Record an error that occurred."""
        if not self.active:
            return

        event = {
            "type": "error",
            "command": command,
            "error": error
        }
        if context:
            event["context"] = context
        self._record(event)

    def record_dialogue(self, speaker: str = None, text: str = None, options: List[str] = None):
        """Record dialogue state for quest tracking."""
        if not self.active:
            return

        event = {"type": "dialogue"}
        if speaker:
            event["speaker"] = speaker
        if text:
            event["text"] = text
        if options:
            event["options"] = options
        self._record(event)

    def record_dialogue_selection(self, option: str, success: bool = True):
        """Record which dialogue option was selected."""
        if not self.active:
            return

        self._record({
            "type": "dialogue_select",
            "option": option,
            "success": success
        })

    def get_recent_events(self, n: int = 10) -> List[Dict[str, Any]]:
        """Peek at recent events without stopping the session."""
        return self.events[-n:] if self.events else []

    def stop(self) -> Optional[str]:
        """Stop recording and write session to file. Returns filepath."""
        if not self.active:
            return None

        self._record({"type": "session_end"})

        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Build session document
        session_doc = {
            "session": {
                "id": self.session_id,
                "goal": self.goal,
                "start_time": self.events[0]["timestamp"] if self.events else None,
                "end_time": self.events[-1]["timestamp"] if self.events else None,
                "event_count": len(self.events)
            },
            "events": self.events
        }

        filepath = self.output_dir / f"session_{self.session_id}.yaml"

        with open(filepath, 'w') as f:
            yaml.dump(session_doc, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

        self.active = False
        return str(filepath)

    def is_active(self) -> bool:
        """Check if recording is active."""
        return self.active

    def _record(self, event: dict):
        """Add timestamp and append event."""
        event["timestamp"] = datetime.now().isoformat(timespec='milliseconds')
        self.events.append(event)


# Singleton instance
recorder = SessionRecorder()


# ============================================================================
# MCP Tool Handlers
# ============================================================================

@registry.register({
    "name": "start_session_recording",
    "description": """[Session] Start recording commands and state changes to a YAML session file.

Use this when starting a task you may want to replay or debug later.
The session captures:
- All commands sent (with timestamps)
- State changes (inventory, location, equipment, dialogue)
- Markers you add for phases/checkpoints
- Errors encountered

After stopping, converts successful sessions to reusable routines.

Examples:
- start_session_recording(goal="Complete The Restless Ghost quest")
- start_session_recording(goal="Fish 100 lobsters at Musa Point")""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "goal": {
                "type": "string",
                "description": "What you're trying to accomplish (e.g., 'Complete quest X', 'Train fishing to 50')"
            },
            "account": {
                "type": "string",
                "description": "Account name for reference (optional)"
            }
        }
    }
})
async def handle_start_session_recording(arguments: dict) -> dict:
    """Start a new recording session."""
    if recorder.is_active():
        return {
            "success": False,
            "error": "Recording already active",
            "session_id": recorder.session_id
        }

    session_id = recorder.start(
        goal=arguments.get("goal"),
        account=arguments.get("account")
    )

    return {
        "success": True,
        "session_id": session_id,
        "message": f"Recording started. Use stop_session_recording() when done.",
        "output_path": f"/tmp/manny_sessions/session_{session_id}.yaml"
    }


@registry.register({
    "name": "stop_session_recording",
    "description": """[Session] Stop recording and save the session to a YAML file.

Returns the filepath of the saved session. Use this file to:
- Debug what went wrong
- Convert to a reusable routine
- Review the sequence of actions

The session file can be converted to a routine with session_to_routine().""",
    "inputSchema": {
        "type": "object",
        "properties": {}
    }
})
async def handle_stop_session_recording(arguments: dict) -> dict:
    """Stop recording and save session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active"
        }

    filepath = recorder.stop()

    return {
        "success": True,
        "filepath": filepath,
        "message": f"Session saved to {filepath}"
    }


@registry.register({
    "name": "add_session_marker",
    "description": """[Session] Add a marker/checkpoint to the current session.

Use markers to:
- Denote phase transitions ("Phase 2: Get amulet from Father Urhney")
- Mark discovered pitfalls ("PITFALL: EQUIP_ITEM command doesn't exist")
- Note important observations

Markers help when reviewing sessions later.""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "label": {
                "type": "string",
                "description": "Short label for the marker (e.g., 'Phase 2: Get amulet')"
            },
            "note": {
                "type": "string",
                "description": "Optional longer note with details"
            }
        },
        "required": ["label"]
    }
})
async def handle_add_session_marker(arguments: dict) -> dict:
    """Add a marker to the session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active"
        }

    recorder.add_marker(
        label=arguments["label"],
        note=arguments.get("note")
    )

    return {
        "success": True,
        "message": f"Marker added: {arguments['label']}"
    }


@registry.register({
    "name": "get_session_events",
    "description": """[Session] Peek at recent events in the current session.

Use this to review what's been recorded without stopping the session.
Useful for debugging mid-session.""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "last_n": {
                "type": "integer",
                "description": "Number of recent events to return (default: 10)",
                "default": 10
            }
        }
    }
})
async def handle_get_session_events(arguments: dict) -> dict:
    """Get recent events from active session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active",
            "events": []
        }

    n = arguments.get("last_n", 10)
    events = recorder.get_recent_events(n)

    return {
        "success": True,
        "recording_active": True,
        "session_id": recorder.session_id,
        "total_events": len(recorder.events),
        "events": events
    }


@registry.register({
    "name": "session_to_routine",
    "description": """[Session] Convert a recorded session to a routine YAML file.

Extracts commands from a session file and formats them as routine steps.
Use after a successful manual session to create a replayable routine.

Note: You may need to edit the output to:
- Add await_conditions for timing
- Remove failed/retry commands
- Add loop configuration""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "session_path": {
                "type": "string",
                "description": "Path to session YAML file (e.g., '/tmp/manny_sessions/session_20250115_234500.yaml')"
            },
            "output_path": {
                "type": "string",
                "description": "Where to save the routine (optional, prints to response if omitted)"
            },
            "include_markers": {
                "type": "boolean",
                "description": "Include markers as comments in the routine (default: true)",
                "default": True
            }
        },
        "required": ["session_path"]
    }
})
async def handle_session_to_routine(arguments: dict) -> dict:
    """Convert a session file to a routine."""
    session_path = Path(arguments["session_path"])

    if not session_path.exists():
        return {
            "success": False,
            "error": f"Session file not found: {session_path}"
        }

    try:
        with open(session_path) as f:
            session = yaml.safe_load(f)
    except Exception as e:
        return {
            "success": False,
            "error": f"Failed to parse session: {e}"
        }

    events = session.get("events", [])
    session_info = session.get("session", {})
    include_markers = arguments.get("include_markers", True)

    # Build routine steps
    steps = []
    step_id = 0
    current_phase = None

    for event in events:
        event_type = event.get("type")

        if event_type == "marker" and include_markers:
            current_phase = event.get("label")
            continue

        if event_type == "command":
            step_id += 1
            command = event.get("command", "")
            parts = command.split(maxsplit=1)

            step = {
                "id": step_id,
                "action": parts[0] if parts else "",
                "description": event.get("description", "")
            }

            if len(parts) > 1:
                step["args"] = parts[1]

            if current_phase:
                step["phase"] = current_phase

            steps.append(step)

    # Build routine document
    routine = {
        "name": session_info.get("goal", "Extracted Routine"),
        "description": f"Auto-generated from session {session_info.get('id', 'unknown')}",
        "source_session": str(session_path),
        "steps": steps
    }

    # Output
    output_path = arguments.get("output_path")
    if output_path:
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w') as f:
            yaml.dump(routine, f, default_flow_style=False, sort_keys=False)

        return {
            "success": True,
            "output_path": str(output_file),
            "step_count": len(steps),
            "message": f"Routine saved to {output_file}"
        }
    else:
        return {
            "success": True,
            "routine": routine,
            "step_count": len(steps),
            "yaml": yaml.dump(routine, default_flow_style=False, sort_keys=False)
        }


@registry.register({
    "name": "is_session_recording",
    "description": """[Session] Check if session recording is currently active.""",
    "inputSchema": {
        "type": "object",
        "properties": {}
    }
})
async def handle_is_session_recording(arguments: dict) -> dict:
    """Check recording status."""
    return {
        "active": recorder.is_active(),
        "session_id": recorder.session_id if recorder.is_active() else None,
        "event_count": len(recorder.events) if recorder.is_active() else 0
    }


@registry.register({
    "name": "get_command_history",
    "description": """[Session] Get recent commands from the always-on command log.

Commands are ALWAYS logged to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml,
regardless of whether explicit session recording is active.

Use this to see what commands were sent recently, even if you forgot to
start a recording session.

Examples:
- get_command_history() - Last 50 commands from today
- get_command_history(last_n=100) - Last 100 commands
- get_command_history(date="2025-01-15") - Commands from specific day""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "last_n": {
                "type": "integer",
                "description": "Number of recent commands to return (default: 50)",
                "default": 50
            },
            "date": {
                "type": "string",
                "description": "Specific date to query (YYYY-MM-DD format). Defaults to today."
            }
        }
    }
})
async def handle_get_command_history(arguments: dict) -> dict:
    """Get recent commands from the always-on log."""
    n = arguments.get("last_n", 50)
    date_str = arguments.get("date")

    commands = command_log.get_recent_commands(n=n, date_str=date_str)
    log_files = command_log.get_log_files()

    return {
        "success": True,
        "count": len(commands),
        "commands": commands,
        "available_logs": log_files[:7],  # Show last 7 days
        "log_directory": str(command_log.output_dir)
    }


# ============================================================================
# Action Log Tools (reads from plugin-side ActionRecorder)
# ============================================================================

def _get_actions_file(account_id: str = None) -> str:
    """Get the actions file path for an account."""
    if account_id and account_id != "default":
        return f"/tmp/manny_{account_id}_actions.json"
    return "/tmp/manny_actions.json"


def _find_actions_files() -> List[str]:
    """Find all action log files across accounts."""
    import glob
    files = glob.glob("/tmp/manny_*_actions.json") + glob.glob("/tmp/manny_actions.json")
    return sorted(set(files))


@registry.register({
    "name": "get_action_log",
    "description": """[Session] Read the always-on action log from manual play.

The plugin continuously records ALL manual clicks (mining, banking, casting spells,
walking, etc.) to a JSON file. This captures what the user actually did in-game,
even without any MCP commands being sent.

Use this to:
- See what the user was doing manually (mine, bank, superheat loop)
- Build YAML routines from manual play patterns
- Understand the user's workflow before automating it

The action log includes:
- High-level commands (MINE_ORE Iron, BANK_OPEN, CAST_SPELL Superheat_Item)
- Player position at each action
- Inventory snapshot at each action
- XP gains between actions
- Game chat messages between actions

Examples:
- get_action_log(since_seconds=300) - Last 5 minutes of play
- get_action_log(since_seconds=1800, account_id="main") - Last 30 min on main
- get_action_log() - All recorded actions (up to 500)""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "since_seconds": {
                "type": "integer",
                "description": "Only return actions from the last N seconds (default: return all)"
            },
            "account_id": {
                "type": "string",
                "description": "Account to read actions for (default: auto-detect from running instances)"
            }
        }
    }
})
async def handle_get_action_log(arguments: dict) -> dict:
    """Read the action log from the plugin's ActionRecorder."""
    account_id = arguments.get("account_id")
    since_seconds = arguments.get("since_seconds")

    # Try to find the actions file
    if account_id:
        actions_file = _get_actions_file(account_id)
    else:
        # Auto-detect: find any actions file
        files = _find_actions_files()
        if not files:
            return {
                "success": False,
                "error": "No action log files found. Is RuneLite running with the manny plugin?",
                "hint": "Action logs are written to /tmp/manny_<account>_actions.json"
            }
        actions_file = files[0]  # Use most recent

    if not os.path.exists(actions_file):
        return {
            "success": False,
            "error": f"Action log not found: {actions_file}",
            "hint": "Start RuneLite and perform some actions. The log is created automatically."
        }

    try:
        with open(actions_file) as f:
            data = json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        return {
            "success": False,
            "error": f"Failed to read action log: {e}"
        }

    actions = data.get("actions", [])

    # Filter by time if requested
    if since_seconds:
        cutoff_ms = (time.time() - since_seconds) * 1000
        actions = [a for a in actions if a.get("ts", 0) >= cutoff_ms]

    return {
        "success": True,
        "accountId": data.get("accountId", "unknown"),
        "eventCount": len(actions),
        "totalRecorded": data.get("eventCount", 0),
        "durationSeconds": data.get("durationSeconds", 0),
        "actions": actions,
        "file": actions_file
    }


@registry.register({
    "name": "clear_action_log",
    "description": """[Session] Clear the action log buffer for a fresh start.

Use this before asking the user to demonstrate a workflow, so the log
only contains the relevant actions.

Note: This deletes the action log file. The plugin will create a new one
as soon as new actions are performed.""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "account_id": {
                "type": "string",
                "description": "Account to clear actions for (default: all accounts)"
            }
        }
    }
})
async def handle_clear_action_log(arguments: dict) -> dict:
    """Clear the action log file."""
    account_id = arguments.get("account_id")

    if account_id:
        files = [_get_actions_file(account_id)]
    else:
        files = _find_actions_files()

    cleared = []
    for f in files:
        if os.path.exists(f):
            try:
                os.remove(f)
                cleared.append(f)
            except IOError as e:
                return {"success": False, "error": f"Failed to clear {f}: {e}"}

    return {
        "success": True,
        "cleared": cleared,
        "message": f"Cleared {len(cleared)} action log file(s). New actions will be recorded automatically."
    }


@registry.register({
    "name": "action_log_to_routine",
    "description": """[Session] Convert a manual play action log to a YAML routine draft.

Reads the action log, identifies repeating patterns, and generates a draft
YAML routine with appropriate steps, await_conditions, and loop configuration.

Use this after the user has demonstrated a workflow manually (e.g., mine→superheat→bank loop).

The generated routine is a DRAFT - review and adjust:
- Verify await_conditions are correct
- Adjust timeouts
- Add error handling steps
- Configure loop count

Examples:
- action_log_to_routine(since_seconds=1800) - Build from last 30 min
- action_log_to_routine(output_path="routines/skilling/my_routine.yaml")""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "since_seconds": {
                "type": "integer",
                "description": "Only use actions from the last N seconds"
            },
            "account_id": {
                "type": "string",
                "description": "Account to read actions for"
            },
            "output_path": {
                "type": "string",
                "description": "Where to save the routine YAML (optional, returns inline if omitted)"
            },
            "routine_name": {
                "type": "string",
                "description": "Name for the routine (default: auto-generated)"
            }
        }
    }
})
async def handle_action_log_to_routine(arguments: dict) -> dict:
    """Convert action log to a YAML routine draft."""
    # First, get the action log
    log_result = await handle_get_action_log({
        "since_seconds": arguments.get("since_seconds"),
        "account_id": arguments.get("account_id")
    })

    if not log_result.get("success"):
        return log_result

    actions = log_result.get("actions", [])
    if not actions:
        return {
            "success": False,
            "error": "No actions found in the log. Play manually first, then try again."
        }

    # Filter out noisy/irrelevant actions
    meaningful_actions = []
    for action in actions:
        cmd = action.get("command", "")
        # Skip WALK actions that are just repositioning (keep significant ones)
        # Skip generic CLICK_WIDGET with no useful info
        if cmd in ("CANCEL", "CLICK_WIDGET", ""):
            continue
        meaningful_actions.append(action)

    if not meaningful_actions:
        return {
            "success": False,
            "error": "No meaningful actions found (only walks/cancels). Perform more game actions."
        }

    # Build routine steps
    routine_name = arguments.get("routine_name", "Manual Play Routine")
    steps = []
    step_id = 0

    for action in meaningful_actions:
        step_id += 1
        cmd = action.get("command", "")
        parts = cmd.split(maxsplit=1)

        step = {
            "id": step_id,
            "command": cmd,
            "description": f"{action.get('option', '')} {action.get('target', '')}".strip(),
        }

        # Add position context
        step["position"] = f"{action.get('x', 0)},{action.get('y', 0)},{action.get('plane', 0)}"

        # Add await conditions based on command type
        if parts and parts[0] in ("MINE_ORE", "CHOP_TREE"):
            # Mining/woodcutting - await item or idle
            step["await_condition"] = "idle"
            step["timeout_ms"] = 15000
        elif parts and parts[0] == "GOTO":
            coords = parts[1] if len(parts) > 1 else ""
            xy = coords.replace(" ", ",").split(",")
            if len(xy) >= 2:
                step["await_condition"] = f"location:{xy[0]},{xy[1]}"
                step["timeout_ms"] = 30000
        elif parts and parts[0] == "BANK_OPEN":
            step["await_condition"] = "idle"
            step["timeout_ms"] = 5000

        # Add XP context as comment
        xp = action.get("xpGains")
        if xp:
            step["xp_gains"] = xp

        # Add inventory context
        inv_delta = action.get("inventoryDelta")
        if inv_delta:
            step["inventory_delta"] = inv_delta

        steps.append(step)

    # Detect loop patterns (simplified: look for command sequence repetition)
    loop_info = _detect_loop_pattern(meaningful_actions)

    # Build routine document
    routine = {
        "name": routine_name,
        "description": f"Auto-generated from {len(meaningful_actions)} manual actions",
        "generated_from": "action_log",
        "generated_at": datetime.now().isoformat(),
    }

    if loop_info:
        routine["loop"] = loop_info

    routine["steps"] = steps

    # Output
    output_path = arguments.get("output_path")
    if output_path:
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w') as f:
            yaml.dump(routine, f, default_flow_style=False, sort_keys=False)

        return {
            "success": True,
            "output_path": str(output_file),
            "step_count": len(steps),
            "loop_detected": loop_info is not None,
            "message": f"Routine draft saved to {output_file}. Review and adjust await_conditions and timeouts."
        }
    else:
        return {
            "success": True,
            "routine": routine,
            "step_count": len(steps),
            "loop_detected": loop_info is not None,
            "yaml": yaml.dump(routine, default_flow_style=False, sort_keys=False),
            "message": "Routine draft generated. Review and adjust await_conditions and timeouts."
        }


def _detect_loop_pattern(actions: List[Dict]) -> Optional[Dict]:
    """
    Simple loop detection: look for repeating command sequences.
    Returns loop config if a pattern is found.
    """
    if len(actions) < 4:
        return None

    commands = [a.get("command", "") for a in actions]

    # Try different loop lengths (3-20 steps)
    for loop_len in range(3, min(21, len(commands) // 2 + 1)):
        # Check if the first loop_len commands repeat
        pattern = commands[:loop_len]
        repetitions = 0

        for i in range(0, len(commands) - loop_len + 1, loop_len):
            chunk = commands[i:i + loop_len]
            if chunk == pattern:
                repetitions += 1
            else:
                break

        if repetitions >= 2:
            return {
                "detected": True,
                "loop_length": loop_len,
                "repetitions_seen": repetitions,
                "pattern_commands": pattern,
                "note": "Loop pattern detected. Consider wrapping steps 1-{} in a loop.".format(loop_len)
            }

    return None
