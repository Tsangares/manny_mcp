"""
Session Recording for MCP Server

Records commands, state changes, and events to YAML files for:
- Debugging failed sessions
- Converting successful sessions to reusable routines
- Understanding patterns and pitfalls

Two recording modes:
1. Always-on command log: Every command is logged to daily file (lightweight)
2. Explicit session recording: Full state tracking with deltas (start/stop)

Usage:
    # Commands are ALWAYS logged to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml

    # For full session tracking:
    start_session_recording(goal="Complete quest X")
    # ... autonomous play ...
    add_session_marker(label="Phase 2 complete")
    # ... more play ...
    stop_session_recording()  # Returns filepath
"""

import yaml
import json
import os
from datetime import datetime, date
from pathlib import Path
from typing import Optional, Dict, Any, List, Set

from ..registry import registry


# ============================================================================
# Always-On Command Log (lightweight, daily files)
# ============================================================================

class CommandLog:
    """
    Always-on command logging to daily files.

    Every command is appended to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml
    This runs regardless of whether explicit session recording is active.
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self.output_dir = Path("/tmp/manny_sessions")
        self._current_date: Optional[date] = None
        self._current_file: Optional[Path] = None
        self._initialized = True

    def _get_daily_file(self) -> Path:
        """Get the log file for today, creating if needed."""
        today = date.today()

        # Check if we need to rotate to new day's file
        if self._current_date != today:
            self._current_date = today
            self._current_file = self.output_dir / f"commands_{today.isoformat()}.yaml"

            # Ensure directory exists
            self.output_dir.mkdir(parents=True, exist_ok=True)

            # Initialize file with header if new
            if not self._current_file.exists():
                with open(self._current_file, 'w') as f:
                    f.write(f"# Command log for {today.isoformat()}\n")
                    f.write("# Auto-generated by manny MCP server\n")
                    f.write("commands:\n")

        return self._current_file

    def log_command(self, command: str):
        """Append a command to today's log file."""
        try:
            filepath = self._get_daily_file()
            timestamp = datetime.now().isoformat(timespec='milliseconds')

            # Append as YAML list item
            with open(filepath, 'a') as f:
                f.write(f"  - timestamp: \"{timestamp}\"\n")
                # Escape quotes in command for YAML safety
                escaped_cmd = command.replace('"', '\\"')
                f.write(f"    command: \"{escaped_cmd}\"\n")
        except Exception:
            # Don't let logging failures break command execution
            pass

    def get_recent_commands(self, n: int = 50, date_str: str = None) -> List[Dict[str, str]]:
        """Get recent commands from log file."""
        if date_str:
            filepath = self.output_dir / f"commands_{date_str}.yaml"
        else:
            filepath = self._get_daily_file()

        if not filepath or not filepath.exists():
            return []

        try:
            with open(filepath) as f:
                data = yaml.safe_load(f)

            commands = data.get("commands", []) if data else []
            return commands[-n:] if commands else []
        except Exception:
            return []

    def get_log_files(self) -> List[str]:
        """List available command log files."""
        if not self.output_dir.exists():
            return []

        files = sorted(self.output_dir.glob("commands_*.yaml"), reverse=True)
        return [f.name for f in files]


# Singleton instance for always-on logging
command_log = CommandLog()


class SessionRecorder:
    """
    Singleton session recorder that captures commands and state deltas.

    Design decisions:
    - Delta-only state recording (not full snapshots) to keep files small
    - Explicit lifecycle (start/stop) not always-on
    - Command-result correlation via IDs
    - Buffered writes for performance
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self.active = False
        self.session_id: Optional[str] = None
        self.events: List[Dict[str, Any]] = []
        self.last_state: Optional[Dict[str, Any]] = None
        self.command_counter = 0
        self.goal: Optional[str] = None
        self.output_dir = Path("/tmp/manny_sessions")
        self._initialized = True

    def start(self, goal: str = None, account: str = None) -> str:
        """Start a new recording session."""
        self.session_id = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.events = []
        self.last_state = None
        self.command_counter = 0
        self.goal = goal
        self.active = True

        self._record({
            "type": "session_start",
            "goal": goal,
            "account": account
        })

        return self.session_id

    def record_command(self, command: str, description: str = None) -> Optional[int]:
        """Record a command being sent. Returns command ID for correlation."""
        if not self.active:
            return None

        self.command_counter += 1
        event = {
            "type": "command",
            "id": self.command_counter,
            "command": command
        }
        if description:
            event["description"] = description

        self._record(event)
        return self.command_counter

    def record_command_result(self, command_id: int, success: bool, error: str = None):
        """Record the result of a command."""
        if not self.active or command_id is None:
            return

        event = {
            "type": "command_result",
            "command_id": command_id,
            "success": success
        }
        if error:
            event["error"] = error

        self._record(event)

    def record_state_delta(self, new_state: dict, command_id: int = None):
        """Record state changes (delta only, not full state)."""
        if not self.active:
            return

        # First state - just store it, don't record
        if self.last_state is None:
            self.last_state = self._extract_trackable_state(new_state)
            return

        new_trackable = self._extract_trackable_state(new_state)
        delta = self._compute_delta(self.last_state, new_trackable)

        if delta:
            event = {"type": "state_delta", "changes": delta}
            if command_id:
                event["triggered_by"] = command_id
            self._record(event)

        self.last_state = new_trackable

    def _extract_trackable_state(self, state: dict) -> dict:
        """Extract the parts of state we track for deltas."""
        player = state.get("player", {})
        return {
            "location": player.get("location"),
            "inventory_items": frozenset(
                item.get("name", "")
                for item in player.get("inventory", {}).get("items", [])
            ),
            "inventory_count": player.get("inventory", {}).get("used", 0),
            "equipment": frozenset(
                v.get("name", "")
                for k, v in player.get("equipment", {}).items()
                if isinstance(v, dict) and v.get("name")
            ),
            "dialogue_open": state.get("dialogue", {}).get("open", False),
            "dialogue_type": state.get("dialogue", {}).get("type"),
            "health": player.get("health", {}).get("current"),
            "in_combat": player.get("inCombat", False),
            "plane": player.get("location", {}).get("plane")
        }

    def _compute_delta(self, old: dict, new: dict) -> dict:
        """Compute what changed between two states."""
        delta = {}

        # Location change
        if old.get("location") != new.get("location"):
            delta["location"] = new.get("location")

        # Plane change (important for ladders/stairs)
        if old.get("plane") != new.get("plane"):
            delta["plane"] = new.get("plane")

        # Inventory changes
        old_items = old.get("inventory_items", frozenset())
        new_items = new.get("inventory_items", frozenset())

        if added := new_items - old_items:
            delta["inventory_added"] = sorted(added)
        if removed := old_items - new_items:
            delta["inventory_removed"] = sorted(removed)

        # Inventory count
        if old.get("inventory_count") != new.get("inventory_count"):
            delta["inventory_count"] = new.get("inventory_count")

        # Equipment changes
        old_equip = old.get("equipment", frozenset())
        new_equip = new.get("equipment", frozenset())

        if equipped := new_equip - old_equip:
            delta["equipped"] = sorted(equipped)
        if unequipped := old_equip - new_equip:
            delta["unequipped"] = sorted(unequipped)

        # Dialogue state
        if old.get("dialogue_open") != new.get("dialogue_open"):
            delta["dialogue_open"] = new.get("dialogue_open")
        if old.get("dialogue_type") != new.get("dialogue_type"):
            delta["dialogue_type"] = new.get("dialogue_type")

        # Health
        if old.get("health") != new.get("health"):
            delta["health"] = new.get("health")

        # Combat state
        if old.get("in_combat") != new.get("in_combat"):
            delta["in_combat"] = new.get("in_combat")

        return delta

    def add_marker(self, label: str, note: str = None):
        """Add a marker/checkpoint to the session."""
        if not self.active:
            return

        event = {"type": "marker", "label": label}
        if note:
            event["note"] = note
        self._record(event)

    def record_error(self, command: str, error: str, context: dict = None):
        """Record an error that occurred."""
        if not self.active:
            return

        event = {
            "type": "error",
            "command": command,
            "error": error
        }
        if context:
            event["context"] = context
        self._record(event)

    def record_dialogue(self, speaker: str = None, text: str = None, options: List[str] = None):
        """Record dialogue state for quest tracking."""
        if not self.active:
            return

        event = {"type": "dialogue"}
        if speaker:
            event["speaker"] = speaker
        if text:
            event["text"] = text
        if options:
            event["options"] = options
        self._record(event)

    def record_dialogue_selection(self, option: str, success: bool = True):
        """Record which dialogue option was selected."""
        if not self.active:
            return

        self._record({
            "type": "dialogue_select",
            "option": option,
            "success": success
        })

    def get_recent_events(self, n: int = 10) -> List[Dict[str, Any]]:
        """Peek at recent events without stopping the session."""
        return self.events[-n:] if self.events else []

    def stop(self) -> Optional[str]:
        """Stop recording and write session to file. Returns filepath."""
        if not self.active:
            return None

        self._record({"type": "session_end"})

        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Build session document
        session_doc = {
            "session": {
                "id": self.session_id,
                "goal": self.goal,
                "start_time": self.events[0]["timestamp"] if self.events else None,
                "end_time": self.events[-1]["timestamp"] if self.events else None,
                "event_count": len(self.events)
            },
            "events": self.events
        }

        filepath = self.output_dir / f"session_{self.session_id}.yaml"

        with open(filepath, 'w') as f:
            yaml.dump(session_doc, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

        self.active = False
        return str(filepath)

    def is_active(self) -> bool:
        """Check if recording is active."""
        return self.active

    def _record(self, event: dict):
        """Add timestamp and append event."""
        event["timestamp"] = datetime.now().isoformat(timespec='milliseconds')
        self.events.append(event)


# Singleton instance
recorder = SessionRecorder()


# ============================================================================
# MCP Tool Handlers
# ============================================================================

@registry.register({
    "name": "start_session_recording",
    "description": """[Session] Start recording commands and state changes to a YAML session file.

Use this when starting a task you may want to replay or debug later.
The session captures:
- All commands sent (with timestamps)
- State changes (inventory, location, equipment, dialogue)
- Markers you add for phases/checkpoints
- Errors encountered

After stopping, converts successful sessions to reusable routines.

Examples:
- start_session_recording(goal="Complete The Restless Ghost quest")
- start_session_recording(goal="Fish 100 lobsters at Musa Point")""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "goal": {
                "type": "string",
                "description": "What you're trying to accomplish (e.g., 'Complete quest X', 'Train fishing to 50')"
            },
            "account": {
                "type": "string",
                "description": "Account name for reference (optional)"
            }
        }
    }
})
async def handle_start_session_recording(arguments: dict) -> dict:
    """Start a new recording session."""
    if recorder.is_active():
        return {
            "success": False,
            "error": "Recording already active",
            "session_id": recorder.session_id
        }

    session_id = recorder.start(
        goal=arguments.get("goal"),
        account=arguments.get("account")
    )

    return {
        "success": True,
        "session_id": session_id,
        "message": f"Recording started. Use stop_session_recording() when done.",
        "output_path": f"/tmp/manny_sessions/session_{session_id}.yaml"
    }


@registry.register({
    "name": "stop_session_recording",
    "description": """[Session] Stop recording and save the session to a YAML file.

Returns the filepath of the saved session. Use this file to:
- Debug what went wrong
- Convert to a reusable routine
- Review the sequence of actions

The session file can be converted to a routine with session_to_routine().""",
    "inputSchema": {
        "type": "object",
        "properties": {}
    }
})
async def handle_stop_session_recording(arguments: dict) -> dict:
    """Stop recording and save session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active"
        }

    filepath = recorder.stop()

    return {
        "success": True,
        "filepath": filepath,
        "message": f"Session saved to {filepath}"
    }


@registry.register({
    "name": "add_session_marker",
    "description": """[Session] Add a marker/checkpoint to the current session.

Use markers to:
- Denote phase transitions ("Phase 2: Get amulet from Father Urhney")
- Mark discovered pitfalls ("PITFALL: EQUIP_ITEM command doesn't exist")
- Note important observations

Markers help when reviewing sessions later.""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "label": {
                "type": "string",
                "description": "Short label for the marker (e.g., 'Phase 2: Get amulet')"
            },
            "note": {
                "type": "string",
                "description": "Optional longer note with details"
            }
        },
        "required": ["label"]
    }
})
async def handle_add_session_marker(arguments: dict) -> dict:
    """Add a marker to the session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active"
        }

    recorder.add_marker(
        label=arguments["label"],
        note=arguments.get("note")
    )

    return {
        "success": True,
        "message": f"Marker added: {arguments['label']}"
    }


@registry.register({
    "name": "get_session_events",
    "description": """[Session] Peek at recent events in the current session.

Use this to review what's been recorded without stopping the session.
Useful for debugging mid-session.""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "last_n": {
                "type": "integer",
                "description": "Number of recent events to return (default: 10)",
                "default": 10
            }
        }
    }
})
async def handle_get_session_events(arguments: dict) -> dict:
    """Get recent events from active session."""
    if not recorder.is_active():
        return {
            "success": False,
            "error": "No recording active",
            "events": []
        }

    n = arguments.get("last_n", 10)
    events = recorder.get_recent_events(n)

    return {
        "success": True,
        "recording_active": True,
        "session_id": recorder.session_id,
        "total_events": len(recorder.events),
        "events": events
    }


@registry.register({
    "name": "session_to_routine",
    "description": """[Session] Convert a recorded session to a routine YAML file.

Extracts commands from a session file and formats them as routine steps.
Use after a successful manual session to create a replayable routine.

Note: You may need to edit the output to:
- Add await_conditions for timing
- Remove failed/retry commands
- Add loop configuration""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "session_path": {
                "type": "string",
                "description": "Path to session YAML file (e.g., '/tmp/manny_sessions/session_20250115_234500.yaml')"
            },
            "output_path": {
                "type": "string",
                "description": "Where to save the routine (optional, prints to response if omitted)"
            },
            "include_markers": {
                "type": "boolean",
                "description": "Include markers as comments in the routine (default: true)",
                "default": True
            }
        },
        "required": ["session_path"]
    }
})
async def handle_session_to_routine(arguments: dict) -> dict:
    """Convert a session file to a routine."""
    session_path = Path(arguments["session_path"])

    if not session_path.exists():
        return {
            "success": False,
            "error": f"Session file not found: {session_path}"
        }

    try:
        with open(session_path) as f:
            session = yaml.safe_load(f)
    except Exception as e:
        return {
            "success": False,
            "error": f"Failed to parse session: {e}"
        }

    events = session.get("events", [])
    session_info = session.get("session", {})
    include_markers = arguments.get("include_markers", True)

    # Build routine steps
    steps = []
    step_id = 0
    current_phase = None

    for event in events:
        event_type = event.get("type")

        if event_type == "marker" and include_markers:
            current_phase = event.get("label")
            continue

        if event_type == "command":
            step_id += 1
            command = event.get("command", "")
            parts = command.split(maxsplit=1)

            step = {
                "id": step_id,
                "action": parts[0] if parts else "",
                "description": event.get("description", "")
            }

            if len(parts) > 1:
                step["args"] = parts[1]

            if current_phase:
                step["phase"] = current_phase

            steps.append(step)

    # Build routine document
    routine = {
        "name": session_info.get("goal", "Extracted Routine"),
        "description": f"Auto-generated from session {session_info.get('id', 'unknown')}",
        "source_session": str(session_path),
        "steps": steps
    }

    # Output
    output_path = arguments.get("output_path")
    if output_path:
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        with open(output_file, 'w') as f:
            yaml.dump(routine, f, default_flow_style=False, sort_keys=False)

        return {
            "success": True,
            "output_path": str(output_file),
            "step_count": len(steps),
            "message": f"Routine saved to {output_file}"
        }
    else:
        return {
            "success": True,
            "routine": routine,
            "step_count": len(steps),
            "yaml": yaml.dump(routine, default_flow_style=False, sort_keys=False)
        }


@registry.register({
    "name": "is_session_recording",
    "description": """[Session] Check if session recording is currently active.""",
    "inputSchema": {
        "type": "object",
        "properties": {}
    }
})
async def handle_is_session_recording(arguments: dict) -> dict:
    """Check recording status."""
    return {
        "active": recorder.is_active(),
        "session_id": recorder.session_id if recorder.is_active() else None,
        "event_count": len(recorder.events) if recorder.is_active() else 0
    }


@registry.register({
    "name": "get_command_history",
    "description": """[Session] Get recent commands from the always-on command log.

Commands are ALWAYS logged to /tmp/manny_sessions/commands_YYYY-MM-DD.yaml,
regardless of whether explicit session recording is active.

Use this to see what commands were sent recently, even if you forgot to
start a recording session.

Examples:
- get_command_history() - Last 50 commands from today
- get_command_history(last_n=100) - Last 100 commands
- get_command_history(date="2025-01-15") - Commands from specific day""",
    "inputSchema": {
        "type": "object",
        "properties": {
            "last_n": {
                "type": "integer",
                "description": "Number of recent commands to return (default: 50)",
                "default": 50
            },
            "date": {
                "type": "string",
                "description": "Specific date to query (YYYY-MM-DD format). Defaults to today."
            }
        }
    }
})
async def handle_get_command_history(arguments: dict) -> dict:
    """Get recent commands from the always-on log."""
    n = arguments.get("last_n", 50)
    date_str = arguments.get("date")

    commands = command_log.get_recent_commands(n=n, date_str=date_str)
    log_files = command_log.get_log_files()

    return {
        "success": True,
        "count": len(commands),
        "commands": commands,
        "available_logs": log_files[:7],  # Show last 7 days
        "log_directory": str(command_log.output_dir)
    }
