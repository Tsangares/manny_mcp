# Fishing Session - 2025-12-20

## Session Goal
Continue fishing training from level 38 to level 45 at Draynor Village.

## Session Progress
- Started: Level 38 (XP: 33,440)
- Ended: Level 39 (XP: 34,020)
- XP Gained: ~580 XP
- Trips completed: ~2 partial (session cut short for reflection)

---

## Reflections on Autonomous Bot Monitoring

### The Role of the Monitor vs. The Executor

This session crystallized an important distinction: **I am primarily a monitor, not the executor**. The manny plugin runs autonomously in Java threads - my job is to:
1. Observe state changes via `get_game_state()` and `get_logs()`
2. Detect when intervention is needed
3. Issue high-level commands like `FISH_DRAYNOR_LOOP 45`
4. Let the routine run until it fails or completes

**Key insight**: Polling every few seconds to check inventory counts and XP is the right granularity. I don't need to micromanage each fish catch - that's the plugin's job.

### Token Efficiency Through Trust in Routines

The biggest token savings come from **trusting the routine**:
- BAD: Checking logs every 2 seconds, analyzing every fish catch
- GOOD: Checking state every 10-15 seconds, only acting on state changes (inventory full, level up, loop stopped)

**Effective monitoring pattern**:
```
1. Issue command (FISH_DRAYNOR_LOOP 45)
2. Wait for state change (inventory 28/28, location change, error)
3. Verify the routine handled it correctly
4. Only intervene if something went wrong
```

I found myself over-monitoring at times - checking logs too frequently when fishing was working fine. The routine was catching fish; I didn't need to see each "[FISH] Caught 1 fish" message.

### Thread Contention: A Persistent Problem

**Observation**: Multiple background threads (manny-background-0, 1, 2, 3) all try to execute the same command simultaneously. This causes:
- Race conditions on mouse movements
- Click verification failures ("Expected 'Small Net', got 'Walk here'")
- Duplicate log messages for every action
- Wasted cycles as threads compete for the same NPC

**Pattern observed**:
```
[manny-background-0] INFO [INTERACT-NPC] Attempt 1/3 to click 'Fishing spot'
[manny-background-2] INFO [INTERACT-NPC] Attempt 1/3 to click 'Fishing spot'
[manny-background-3] INFO [INTERACT-NPC] Attempt 1/3 to click 'Fishing spot'
```

All three threads trying to click the same spot at the same millisecond.

**Root cause hypothesis**: The command file watcher triggers all idle threads to pick up the same command. Need command-level mutex or single-threaded command execution.

### Client Blocking Code: The CountDownLatch Problem

From previous session and confirmed today: `CountDownLatch.await()` calls in PlayerHelpers.java cause UI lag:
- `menuClickLatch.await(1, TimeUnit.SECONDS)` blocks the calling thread
- When multiple threads block, the game becomes unresponsive
- User clicks during this time can interfere with bot actions

**Potential solutions to explore**:
1. Use non-blocking CompletableFuture patterns
2. Move all blocking waits to a single dedicated thread
3. Use event-driven callbacks instead of synchronous waits

### Navigation: Simple vs. Complex

**What worked**: Simple directional navigation (minimap clicking) for short distances (< 15 tiles). The bank-to-fishing-spot route is straightforward with clear line of sight.

**What struggled**:
- Navigation got stuck at "4 tiles" from destination when near the bank
- Multiple threads issuing competing minimap clicks
- The oscillation problem: distance going 12 -> 11 -> 9 -> 8 -> 4 -> 4 -> 4 (stuck)

**Lesson**: Navigation works best when there's only ONE thread doing it. The thread contention makes it look broken when it's actually the multiplicity that's the issue.

### Click Accuracy: Better Than Expected

Menu click verification system actually works well when given the chance:
- Success rate: ~60-70% on first attempt
- Usually succeeds by attempt 2 or 3
- The retry logic is robust

The failures are mostly due to thread interference, not targeting issues.

---

## Philosophical Takeaways

### On Delegation
A good overseer doesn't do the work - they ensure the workers can do their work effectively. My interventions should be:
- **Rare**: Only when the routine genuinely fails
- **Decisive**: Clear commands that reset to a known good state
- **Patient**: Give the routine time to self-correct before intervening

### On Problem Solving
When something appears broken, the diagnostic order should be:
1. Is it actually broken, or just slow?
2. Is it a symptom (click failed) or root cause (thread contention)?
3. Can I work around it (restart loop) or does it need a code fix?

Today I learned to distinguish between "the fishing loop is broken" (false) and "the fishing loop is slow due to thread contention" (true). The former requires code changes; the latter just requires patience and occasional restarts.

### On Token Usage
The most token-efficient session is one where I:
1. Start the routine
2. Check occasionally (every 30-60 seconds is fine for fishing)
3. Update the user on meaningful milestones (level ups, trip completions)
4. Only dive deep into logs when something actually fails

I probably used 3x more tokens than necessary by over-monitoring the fishing process. Each `get_logs()` call generates context; each analysis costs tokens. Trust the routine.

---

## Technical Notes for Future Sessions

### Effective Commands
- `FISH_DRAYNOR_LOOP 45` - Full loop until target level
- Check state every 15-30 seconds during stable fishing
- Only check logs on state changes or apparent stalls

### Signs the Loop Needs Restart
- Scenario shows "Idle" but inventory not full and at fishing spot
- Same position for > 60 seconds with no fish catches
- Error patterns in logs (3+ consecutive failures)

### Signs to NOT Intervene
- Multiple threads logging the same action (normal, if annoying)
- Occasional click retries (2/3 or 3/3 attempts)
- Brief pauses between fish catches (natural RNG)

---

## Next Session Goals
1. Reach level 45 fishing
2. Monitor less frequently (30-second intervals minimum)
3. Track: commands issued, interventions needed, tokens used
4. Consider: Should the loop detect and handle its own thread contention?
